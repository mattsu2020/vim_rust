use std::ffi::{CStr, CString};
use std::io::{self, Write};
use std::os::raw::{c_char, c_int};

/// Current version of the session file format.
pub const SESSION_VERSION: u32 = 1;

/// Escape spaces and backslashes in a file name so that it can be safely
/// stored in a session file.  This mimics Vim's fnameescape().
pub fn escape_filename(name: &str) -> String {
    let mut escaped = String::with_capacity(name.len());
    for ch in name.chars() {
        match ch {
            ' ' | '\\' => {
                escaped.push('\\');
                escaped.push(ch);
            }
            _ => escaped.push(ch),
        }
    }
    escaped
}

/// Reverse the effect of [`escape_filename`].
pub fn unescape_filename(name: &str) -> String {
    let mut chars = name.chars();
    let mut out = String::with_capacity(name.len());
    while let Some(ch) = chars.next() {
        if ch == '\\' {
            if let Some(next) = chars.next() {
                out.push(next);
            }
        } else {
            out.push(ch);
        }
    }
    out
}

/// Save a session file at `path` with `contents` and a version header.
pub fn save_session(path: &str, contents: &str, version: u32) -> io::Result<()> {
    let mut file = std::fs::File::create(path)?;
    writeln!(file, "# vim session version {}", version)?;
    file.write_all(contents.as_bytes())
}

/// Load a session file from `path`, returning the version and the remaining data.
pub fn load_session(path: &str) -> io::Result<(u32, String)> {
    let content = std::fs::read_to_string(path)?;
    let mut lines = content.lines();
    let ver_line = lines.next().unwrap_or("0");
    let version = ver_line
        .strip_prefix("# vim session version ")
        .and_then(|v| v.parse().ok())
        .unwrap_or(0);
    Ok((version, lines.collect::<Vec<_>>().join("\n")))
}

/// Parse the version from the contents of a viminfo file.
pub fn parse_viminfo_version(contents: &str) -> u32 {
    for line in contents.lines() {
        if let Some(rest) = line.strip_prefix("# This viminfo file was generated by Vim ") {
            let version_str = rest.split_whitespace().next().unwrap_or("0");
            if let Some(major) = version_str.split('.').next().and_then(|v| v.parse().ok()) {
                return major;
            }
        }
    }
    0
}

// FFI wrappers ----------------------------------------------------------------

/// Escape a file name.  Returns a newly allocated C string that must be freed
/// with `CString::from_raw` by the caller.
#[no_mangle]
pub extern "C" fn rs_escape_session_filename(ptr: *const c_char) -> *mut c_char {
    if ptr.is_null() {
        return std::ptr::null_mut();
    }
    let cstr = unsafe { CStr::from_ptr(ptr) };
    match cstr.to_str() {
        Ok(s) => CString::new(escape_filename(s)).unwrap().into_raw(),
        Err(_) => std::ptr::null_mut(),
    }
}

/// Save a session file.
#[no_mangle]
pub extern "C" fn rs_save_session(
    path: *const c_char,
    data: *const c_char,
    len: usize,
    version: u32,
) -> c_int {
    if path.is_null() || data.is_null() {
        return -1;
    }
    let c_path = unsafe { CStr::from_ptr(path) };
    let slice = unsafe { std::slice::from_raw_parts(data as *const u8, len) };
    let content = match std::str::from_utf8(slice) {
        Ok(s) => s,
        Err(_) => return -1,
    };
    match c_path.to_str() {
        Ok(p) => match save_session(p, content, version) {
            Ok(_) => 0,
            Err(_) => -1,
        },
        Err(_) => -1,
    }
}

/// Load a session file.  The caller is responsible for freeing the returned
/// string using `CString::from_raw`.
#[no_mangle]
pub extern "C" fn rs_load_session(path: *const c_char, out_version: *mut u32) -> *mut c_char {
    if path.is_null() {
        return std::ptr::null_mut();
    }
    let c_path = unsafe { CStr::from_ptr(path) };
    let p = match c_path.to_str() {
        Ok(p) => p,
        Err(_) => return std::ptr::null_mut(),
    };
    match load_session(p) {
        Ok((version, data)) => {
            unsafe {
                if !out_version.is_null() {
                    *out_version = version;
                }
            }
            CString::new(data).unwrap().into_raw()
        }
        Err(_) => std::ptr::null_mut(),
    }
}

/// Parse the version from a viminfo file on disk.
#[no_mangle]
pub extern "C" fn rs_parse_viminfo(path: *const c_char) -> u32 {
    if path.is_null() {
        return 0;
    }
    let c_path = unsafe { CStr::from_ptr(path) };
    let p = match c_path.to_str() {
        Ok(p) => p,
        Err(_) => return 0,
    };
    match std::fs::read_to_string(p) {
        Ok(s) => parse_viminfo_version(&s),
        Err(_) => 0,
    }
}

// Tests -----------------------------------------------------------------------

#[cfg(test)]
mod tests {
    use super::*;
    use std::ffi::CString;
    use std::fs;

    #[test]
    fn escape_roundtrip() {
        let name = "path with spaces";
        let esc = escape_filename(name);
        assert_eq!(esc, "path\\ with\\ spaces");
        assert_eq!(unescape_filename(&esc), name);
    }

    #[test]
    fn save_and_load_session() {
        let path = "Xtest_session.vim";
        let content = "set number";
        save_session(path, content, SESSION_VERSION).unwrap();
        let (ver, data) = load_session(path).unwrap();
        assert_eq!(ver, SESSION_VERSION);
        assert_eq!(data, content);
        fs::remove_file(path).unwrap();
    }

    #[test]
    fn parse_viminfo_versions() {
        let new = "# This viminfo file was generated by Vim 9.1.\n";
        let old = "# This viminfo file was generated by Vim 8.2.\n";
        assert_eq!(parse_viminfo_version(new), 9);
        assert_eq!(parse_viminfo_version(old), 8);
    }

    #[test]
    fn ffi_roundtrip() {
        let path = CString::new("Xffi_session.vim").unwrap();
        let data = b"echo test";
        assert_eq!(
            rs_save_session(
                path.as_ptr(),
                data.as_ptr() as *const c_char,
                data.len(),
                SESSION_VERSION
            ),
            0
        );
        let mut ver = 0u32;
        let loaded_ptr = rs_load_session(path.as_ptr(), &mut ver as *mut u32);
        assert_eq!(ver, SESSION_VERSION);
        let loaded = unsafe { CString::from_raw(loaded_ptr) };
        assert_eq!(loaded.to_str().unwrap(), "echo test");
        fs::remove_file("Xffi_session.vim").unwrap();
    }

    #[test]
    fn viminfo_compat() {
        let contents = "# This viminfo file was generated by Vim 8.0.\n";
        fs::write("Xviminfo", contents).unwrap();
        assert_eq!(
            rs_parse_viminfo(CString::new("Xviminfo").unwrap().as_ptr()),
            8
        );
        fs::remove_file("Xviminfo").unwrap();
    }
}
